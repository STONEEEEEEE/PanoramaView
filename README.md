# panoramaView

##  一、panoramaViewByHand.py

#### python版本和opencv版本

python版本在3.7及以下

opencv使用3.4.2.16

下载地址：[Links for opencv-python (tsinghua.edu.cn)](https://pypi.tuna.tsinghua.edu.cn/simple/opencv-python/)

找对应的版本下载即可，注意cp代表的是python版本，如cp37代表python3.7

#### 算法流程

根据尺度不变特征变换原理提取图片的特征点，实现使用opencv创建一个SIFT对象，SIFT对象使用DoG方法检测关键点，并对每个关键点周围的区域计算特征向量。在实现时，可以使用比SIFT快的SURF方法，使用Hessian算法检测关键点。因为只是进行全景图拼接，在使用SURF时，还可以调节它的参数，减少一些关键点，只获取64维而不是128维的向量等，加快速度。
在分别提取好了两张图片的关键点和特征向量以后，可以利用它们进行两张图片的匹配。在拼接图片中，可以使用Knn进行匹配，但是使用FLANN快速匹配库更快，图片拼接，需要用到FLANN的单应性匹配。
单应性匹配完之后可以获得透视变换H矩阵，用这个的逆矩阵来对第二幅图片进行透视变换，将其转到和第一张图一样的视角，为下一步拼接做准备。
透视变换完的图片，其大小就是最后全景图的大小，它的右边是透视变换以后的图片，左边是黑色没有信息。拼接时可以比较简单地处理，通过numpy数组选择直接把第一张图加到它的左边，覆盖掉重叠部分，得到拼接图片，这样做非常快，但是最后效果不是很好，中间有一条分割痕迹非常明显。使用opencv指南中图像金字塔的代码对拼接好的图片进行处理，整个图片平滑了，中间的缝还是特别突兀。
直接拼效果不是很好，可以把第一张图叠在左边，但是对第一张图和它的重叠区做一些加权处理，重叠部分，离左边图近的，左边图的权重就高一些，离右边近的，右边旋转图的权重就高一些，然后两者相加，使得过渡是平滑地，这样看上去效果好一些，速度就比较慢。如果是用SURF来做，时间主要画在平滑处理上而不是特征点提取和匹配。



## 二、panoramaView.py

该文件使用的是opencv自带的两个方法，虽然没搞懂实现原理，但是就结果而言比其他拼接方法快很多而且质量也非常高。生成的图像也不是以中心图像为基准点，所以边缘图像不会发生大形变

但是拼接完成的全景图边缘会有较大部分的黑边，解决办法可以采用提取全景图轮廓，然后通过腐蚀的方法找到这个轮廓内的最小矩形区域，最终的到去除黑边的图像



## 三、纯python手写方法

速度最慢，明显拼接缝、断裂痕迹，特征点的提取容易失败，特征点较少的情况下会发生大面积形变甚至图形的颠倒
拼接时以中心图像为基准，越边缘的图像经过仿射变换后发生的形变越大



## 四、拼接问题：

有移动的物体拼接会出问题
两幅图在局部的特征上没有差距的话无法作为特征点，如树林、草坪、天空

